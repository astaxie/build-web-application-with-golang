# 4.4 Дублирование отправки

Не знаю, встречали ли Вы, как на каком-либо блоге или форуме размещено несколько постов подряд с одинаковым содержимым, но я могу сказать Вам, что это происходит по причине того, что отправка постов дублируется пользователем. Это может произойти по многим причинам; иногда пользователь отправляет форму двойным щелчком, или он после отправки решает исправить содержимое поста и нажимает кнопку браузера "Назад". А иногда это - намеренные действия злоумышленников. Понятно, что дублирование отправки может привести ко многим проблемам. Поэтому нам нужно принимать эффективные меры для его предотвращения.

Решением этой задачи является добавление в форму скрытого поля с уникальным токеном и проверка этого токена перед обработкой введенных данных. А если для отправки формы Вы используете Ajax, можно после того, как данные отправлены, сделать кнопку отправки неактивной.

Давайте усовершенствуем пример из раздела 4.2:
```html
	<input type="checkbox" name="interest" value="football">Футбол
	<input type="checkbox" name="interest" value="basketball">Баскетбол
	<input type="checkbox" name="interest" value="tennis">Теннис
	Имя:<input type="text" name="username">
	Пароль:<input type="password" name="password">
	<input type="hidden" name="token" value="{{.}}">
	<input type="submit" value="Login">
```
Для того, чтобы сгенерировать токен, мы используем хэш MD5 (временная отметка), и добавляем его как в скрытое поле формы ввода данных на стороне клиента, так и в сессионный куки на стороне сервера (см. Раздел 6). Мы можем использовать этот токен для того, чтобы проверить, отправлялись ли уже данные с этой формы:
```Go
func login(w http.ResponseWriter, r *http.Request) {
	fmt.Println("method:", r.Method) // получаем метод запроса
	if r.Method == "GET" {
		crutime := time.Now().Unix()
		h := md5.New()
		io.WriteString(h, strconv.FormatInt(crutime, 10))
		token := fmt.Sprintf("%x", h.Sum(nil))

		t, _ := template.ParseFiles("login.gtpl")
		t.Execute(w, token)
	} else {
		// запрос данных о входе
		r.ParseForm()
		token := r.Form.Get("token")
		if token != "" {
			// проверяем валидность токена
		} else {
			// если нет токена, возвращаем ошибку
		}
		fmt.Println("username length:", len(r.Form["username"][0]))
		fmt.Println("username:", template.HTMLEscapeString(r.Form.Get("username"))) // печатаем на стороне сервера
		fmt.Println("password:", template.HTMLEscapeString(r.Form.Get("password")))
		template.HTMLEscape(w, []byte(r.Form.Get("username"))) // отвечаем клиенту
	}
}
```
![](images/4.4.token.png?raw=true)

Рисунок 4.4 Содержимое браузера после добавления токена

Если обновлять страницу, можно видеть каждый раз новый токен. Это обеспечивает то, что каждая форма уникальна.

На данный момент Вы можете предотвращать множество атак на основе дублирования отправки посредством добавления в формы токенов, но все атаки такого типа предотвратить таким образом нельзя. Для этого нужно проделать еще больше работы.
 
## Ссылки

- [Содержание](preface.md)
- Предыдущий раздел: [Межсайтовый скриптинг](04.3.md)
- Следующий раздел: [Загрузка файлов](04.5.md)
